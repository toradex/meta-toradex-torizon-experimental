#!/bin/bash
# -*- mode: shell-script-mode; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
#
# Copyright (C) 2012-13 O.S. Systems Software LTDA.
# Copyright (C) 2017 Open Source Foundries Ltd.
# Authored-by:  Otavio Salvador <otavio@ossystems.com.br>
# Adopted to Angstrom:  Khem Raj <raj.khem@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

env_cleanup() {
    unset MACHLAYERS DISTLAYERS DISTRO_DEFAULT OEROOT
    unset ITEM MANIFESTS EULA EULA_MACHINE REPLY READ_EULA
    unset usage oldmach
    unset MANIFEST_FILE INTEGRATION_BUILD
}

usage () {
    cat >&2 <<EOF

Usage: [DISTRO=<DISTRO>] [MACHINE=<MACHINE>] source ${BASH_SOURCE[0]} [BUILDDIR]

If no DISTRO is set, 'torizon|torizon-upstream' will be chosen depending on MACHINE.
If no MACHINE is set, list all possible machines, and ask user to choose.
If no BUILDIR is set, it will be set to build-\$DISTRO.

EOF
}

variable_validation() {
    local LAYERS=$1
    local -n VARREF=$2
    local VARNAME=$(echo $2 | tr '[:upper:]' '[:lower:]')

    if [ -z "${VARREF}" -o "${VARREF}" = "INVALID" ]; then
        local VARTABLE=
        for ITEM in ${LAYERS}; do
            VARTABLE="${VARTABLE} $(echo "${ITEM}" | cut -d'(' -f1) \
                      $(echo "${ITEM}" | cut -d'(' -f2 | cut -d')' -f1)"
        done

        # whiptail
        which whiptail > /dev/null 2>&1
        if [ $? -eq 0 ]; then
            VARREF=$(whiptail --title "Available ${VARNAME}s" --menu \
                     "Please choose a ${VARNAME}" 0 0 20 \
                     ${VARTABLE} 3>&1 1>&2 2>&3)
        fi

        # dialog
        if [ -z "${VARREF}" -o "${VARREF}" = "INVALID" ]; then
            which dialog > /dev/null 2>&1
            if [ $? -eq 0 ]; then
                VARREF=$(dialog --title "Available ${VARNAME}s" --menu \
                        "Please choose a ${VARNAME}" 0 0 20 ${VARTABLE} \
                        3>&1 1>&2 2>&3)
            fi
        fi

        # guard against Ctrl-D or cancel
        if [  -z "${VARREF}" -o "${VARREF}" = "INVALID" ]; then
            echo "To choose a ${VARNAME} interactively please install whiptail or dialog."
            echo "To choose a ${VARNAME} non-interactively please use the following:"
            echo "    ${!VARREF}=<your-${VARNAME}> . ./setup-environment"
            echo ""
            echo "Press <ENTER> to see a list of your choices"
            read -r
            echo "${LAYERS}" | sed -e 's/(/ (/g' | sed -e 's/)/)\n/g' |
                    sed -e 's/^ */\t/g'
            return 1
        fi
    fi

    return 0
}

trap env_cleanup RETURN

if [ "$(whoami)" = "root" ]; then
    echo "ERROR: do not build TorizonCore as root. Exiting..." >&2
    return 1
fi

if [ $# -gt 1 ]; then
    usage
    return 1
fi

OEROOT=$(pwd)
cd "$OEROOT"
if [ -n "$ZSH_VERSION" ]; then
    setopt sh_word_split
    setopt clobber
elif [ -n "$BASH_VERSION" ]; then
    set +o noclobber
fi

# Create a common list of "<machine>(<layer>)", sorted by <machine>
# Blacklist unsupported machines of TorizonCore
MACHLAYERS=$(find layers/ -print | grep "conf/machine/.*\.conf" |
            grep -E '(apalis.*\.conf|colibri.*\.conf|verdin.*\.conf|qemuarm64\.conf|genericx86-64\.conf|raspberrypi4-64\.conf)' |
            grep -E -v '(imx7-nand|colibri-vf|tk1|colibri-imx7|colibri-imx6ull)\.conf' |
            sed -e 's/\.conf//g' -e 's/layers\///' |
            awk -F'/conf/machine/' '{print $NF "(" $1 ")"}' | LC_ALL=C sort)

# MACHINE sanity check
echo $MACHLAYERS | grep -q "$MACHINE(.*)" || MACHINE="INVALID"

# Validate MACHINE
variable_validation "$MACHLAYERS" "MACHINE" || return 1

# DISTRO defaults to 'torizon' for imx8/qemuarm64/genericx86-64 machines
# DISTRO defaults to 'torizon-upstream' for other machines
DISTRO_DEFAULT="torizon-upstream" && echo "$MACHINE" | grep -E -q '(imx8|qemuarm64|genericx86-64)' && DISTRO_DEFAULT="torizon"
DISTRO=${DISTRO:-$DISTRO_DEFAULT}

# Create a common list of "<distro>(<layer>)" supported by TorizonCore, sorted by <distro>
DISTLAYERS=$(find layers/meta-toradex-torizon -print | grep "conf/distro/.*\.conf" |
            sed -e 's/\.conf//g' -e 's/layers\///' |
            awk -F'/conf/distro/' '{print $NF "(" $1 ")"}' | LC_ALL=C sort)

# DISTRO sanity check
echo $DISTLAYERS | grep -q "$DISTRO(.*)" || DISTRO="INVALID"

# Validate DISTRO
variable_validation "$DISTLAYERS" "DISTRO" || return 1

if [ -z "${SDKMACHINE}" ]; then
    SDKMACHINE='x86_64'
fi

MANIFESTS="${OEROOT}"/.repo/manifests
SCRIPTS="${OEROOT}"/layers/meta-toradex-torizon/scripts

# We can be called with only 1 parameter max (build folder)
BUILDDIR=${1:-build-$DISTRO}
# If current BUILDDIR is relative then prepend OEROOT
case ${BUILDDIR} in
    /* ) ;;
    *  ) BUILDDIR=$(readlink -f ${BUILDDIR});;
esac
# Get rid of double slash. sed calls in OE staging_processfixme
# seems to have troubles if this makes it into OE variables.
BUILDDIR=${BUILDDIR%%/}

# Set BBPATH for recipetool
BBPATH=${BUILDDIR}

# Clean up PATH, because if it includes tokens to current directories somehow,
# wrong binaries can be used instead of the expected ones during task execution
PATH=$(echo "${PATH}" | sed 's/\(:.\|:\)*:/:/g;s/^.\?://;s/:.\?$//')
PATH="${OEROOT}/bitbake/bin:${OEROOT}/.repo/repo:${PATH}"
PATH="${OEROOT}/layers/openembedded-core/bitbake/bin:${PATH}"
PATH="${OEROOT}/layers/openembedded-core/scripts:${PATH}"
# Remove duplicate path entries
PATH=$(echo "$PATH" |
       awk -F: '{for (i=1;i<=NF;i++) { if ( !x[$i]++ ) printf("%s:",$i); }}' |
       sed 's/:$//')

BB_ENV_EXTRAWHITE_OE="MACHINE DISTRO TCMODE TCLIBC HTTP_PROXY http_proxy \
HTTPS_PROXY https_proxy FTP_PROXY ftp_proxy FTPS_PROXY ftps_proxy ALL_PROXY \
all_proxy NO_PROXY no_proxy SSH_AGENT_PID SSH_AUTH_SOCK BB_SRCREV_POLICY \
SDKMACHINE BB_NUMBER_THREADS BB_NO_NETWORK PARALLEL_MAKE GIT_PROXY_COMMAND \
SOCKS5_PASSWD SOCKS5_USER SCREENDIR STAMPS_DIR BBPATH_EXTRA BB_SETSCENE_ENFORCE"

BB_ENV_EXTRAWHITE="$(echo $BB_ENV_EXTRAWHITE $BB_ENV_EXTRAWHITE_OE | tr ' ' '\n' | LC_ALL=C sort --unique | tr '\n' ' ')"

export PATH
export BUILDDIR
export BBPATH
export BB_ENV_EXTRAWHITE

mkdir -p "${BUILDDIR}"/conf && cd "${BUILDDIR}"
if [ -f "conf/auto.conf" ]; then
    oldmach=$(egrep "^MACHINE \?=" "conf/auto.conf" |
             sed -e 's%^MACHINE ?= %%' | sed -e 's/^"//' -e 's/"$//')
    olddisto=$(egrep "^DISTRO \?=" "conf/auto.conf" |
             sed -e 's%^DISTRO ?= %%' | sed -e 's/^"//' -e 's/"$//')
fi

if [ -e conf/checksum -a "${MACHINE}" = "$oldmach" -a "${DISTRO}" = "$olddisto" ]; then
    if sha512sum --quiet -c conf/checksum >/dev/null 2>&1; then
       return 0
    fi
fi

# Evaluate new checksum and regenerate the conf files
sha512sum "${SCRIPTS}"/setup-environment-internal 2>&1 > conf/checksum

if [ ! -f "conf/local.conf" ]; then
    cp "${SCRIPTS}"/../conf/template/local.conf conf/local.conf
fi
ln -sf "${SCRIPTS}"/../conf/template/bblayers.conf conf/bblayers.conf
ln -sf "${MANIFESTS}"/README.md README.md
ln -sf "${MANIFESTS}" "${OEROOT}"/layers/

MANIFEST_FILE="${MANIFESTS}"/../manifest.xml
INTEGRATION_BUILD=0

if [ -L "$MANIFEST_FILE" ]; then
    if [ "$(basename `readlink -f "$MANIFEST_FILE"`)" != "default.xml" ]; then
        INTEGRATION_BUILD=1
    fi
else
    if ! cat $MANIFEST_FILE | grep -q "torizoncore/default.xml"; then
        INTEGRATION_BUILD=1
    fi
fi

if [ "$INTEGRATION_BUILD" = "1" ]; then
    cat > conf/auto.conf <<EOF
# This is needed when building on integration. With use-head-next you
# always get the newest kernel. Without use-head-next your build may fail.
MACHINEOVERRIDES =. "use-head-next:"

EOF
fi

cat >> conf/auto.conf <<EOF
DISTRO ?= "${DISTRO}"
MACHINE ?= "${MACHINE}"
SDKMACHINE ?= "${SDKMACHINE}"

# Extra options that can be changed by the user
INHERIT += "rm_work"
EOF

cat > conf/site.conf <<_EOF
SCONF_VERSION = "1"

# Where to store sources
DL_DIR ?= "${OEROOT}/downloads"

# Where to save shared state
SSTATE_DIR ?= "${OEROOT}/sstate-cache"

# Where to save the build system work output
TMPDIR = "${BUILDDIR}/tmp"

# Where to save the packages and images
DEPLOY_DIR = "${BUILDDIR}/deploy"

# Go through the Firewall
#HTTP_PROXY = "http://${PROXYHOST}:${PROXYPORT}/"
_EOF

# Handle EULA , if needed. This is a generic method to handle BSPs
# that might (or not) come with a EULA. If a machine has a EULA, we
# assume that its corresponding layers has conf/EULA/$MACHINE file
# with the EULA text, which we will display to the user and request
# for acceptance. If accepted, the variable ACCEPT_EULA_$MACHINE is
# set to 1 in auto.conf, which can later be used by the BSP.
# If the env variable EULA_$MACHINE is set it is used by default,
# without prompting the user.
# FIXME: there is a potential issue if the same $MACHINE is set in
# more than one layer.. but we should assert that earlier
EULA=$(find ${OEROOT}/layers -path "*/conf/eula/$MACHINE" -print | grep -v scripts |
       grep -v openembedded-core || true)

if [ -n "$EULA" ]; then
    # remove '-' since we are constructing a bash variable name here
    EULA_MACHINE="EULA_$(echo "$MACHINE" | sed 's/-//g')"

    # NOTE: indirect reference / dynamic variable
    if [ -n "${!EULA_MACHINE}" ]; then
        # the EULA_$MACHINE variable is set in the environment, so we just
        # configure # ACCEPT_EULA_$MACHINE in auto.conf
        echo "ACCEPT_EULA_$MACHINE = \"${!EULA_MACHINE}\"" >> conf/auto.conf
    else
        # so we need to ask user if he/she accepts the EULA:
        cat <<EOF

The BSP for $MACHINE depends on packages and firmware which are covered by an
End User License Agreement (EULA). To have the right to use these binaries
in your images, you need to read and accept the following...

EOF

        echo
        REPLY=
        while [ -z "$REPLY" ]; do
            echo -n "Would you like to read the EULA ? (y/n) "
            read -r REPLY
            case "$REPLY" in
                y|Y)
                    READ_EULA=1
                    ;;
                n|N)
                    READ_EULA=0
                    ;;
                *)
                    REPLY=
                    ;;
            esac
        done

        if [ "$READ_EULA" = 1 ]; then
            more -d "${EULA}"
            echo
            REPLY=
            while [ -z "$REPLY" ]; do
                echo -n "Do you accept the EULA you just read? (y/n) "
                read -r REPLY
                case "$REPLY" in
                    y|Y)
                        echo "EULA has been accepted."
                        echo "ACCEPT_EULA_$MACHINE = \"1\"" >> conf/auto.conf
                        ;;
                    n|N)
                        echo "EULA has not been accepted."
                        ;;
                    *)
                        REPLY=
                        ;;
                esac
            done
        fi
    fi
fi

cat <<EOF

Welcome to Toradex TorizonCore

For more information about OpenEmbedded see their website:

    http://www.openembedded.org/

Your build environemnt has been configured with:

    MACHINE = ${MACHINE}
    SDKMACHINE = ${SDKMACHINE}
    DISTRO = ${DISTRO}

You can now run 'bitbake <target>'

Some of common targets are:

    torizon-core-docker
    torizon-core-podman
    torizon-core-lite

EOF

if [ "${MACHINE}" = "qemuarm64" ]; then
    cat <<EOF
You can also run generated qemuarm64 image with runqemu by:

    runqemu qemuarm64
    xtightvncviewer 127.0.0.1

EOF
fi

if [ "${MACHINE}" = "genericx86-64" ]; then
    cat <<EOF
You can also run generated genericx86-64 image in VirtualBox by:

    Create a new machine by choosing 'Other Linux (64-bits)' type
    Choose an existing virtual hard disk file: deploy/images/genericx86-64/torizon-core-docker-genericx86-64.wic.vmdk
    Enable EFI boot mode through: Settings -> System -> Extended Features -> Enable EFI
    Start the machine

EOF
fi
